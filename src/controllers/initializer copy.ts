/*
NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mMMMMMMMMMNNNmmNNNMMNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mmNMMNMMMMNNNNNmmmddhdddNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mddNMMNy:/odNmmddmmNNmdhhddmNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmmdNMNd:--+dNmmddhhddmmhsyhhmdmmNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmNmdNmy:.-oyNmmmhmdhho+sososyhhhddNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmmNdh+-`.:oyNNdmmdmmdo-://oysssyhhhdmNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
Nmmmoyyyo+osdNmdmmddNNhs+/::/+osyssydyhdNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NNmhsymMMNmmmmdmdNNddNmsso+++////ossssyyhdmNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mhhhmNNMNNNhssshhmmddmmssyooooso/::+oysshhhhmMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mmdhdddNNdyoosyhdmddmmmsoooooyysyys/::/oyyhhhyMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mdddhddmhsooshdmdmdhhyyyysso/ooo+syhhs/-/+shyhMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
dyyhdmd+ososhdmdmyyhhhhhhhyo++o/+///+ohhso++sdMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
dhdmNNdsossyhmdmsydhssssyhhs/++o/o+//:++yhhy+/hNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mdmNNNNmhysshddyshdyyy/oss+s::/:://++///++++/::hmNNNNNNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NNMNNNmmNNdymNNhshdshdyhdysh+sy+-:++osssosss++yNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmNNNmdNNmNmmmNmyyddyyhdhydyohys/-oo+osssysyyohNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mmNNNhdNmmNNmNMMNhyyhhhdhyyhmmyh+-/s+sysssyyhyydNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mNMMMhdNdmMNMMMMMNNmdhdddmhdmmNho/-osoyyo++oyddhhNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NMMMNmhNdNMNMNMMNmNNNmmmdyoohmhoyo::hsooo++oooydhymMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMNNNhmNNMmmNMNNmmmmdmmdyhhoyddddoo++yoyysooossyhsmMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMNNNmmNNNmdNdNmmddhhhdNNhsmNssdooo/dso++osyyysoymMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMNNNNmNNNNNmddmmNhshNmmmNmNMdhNsh/ohho++/:++MMNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MNNNMMNNNNmmmhhhhdyosdNmdmMMhoNmhdmys+ooo++/+MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mmNNNMMNNNNmddmdoodmMMNmmNNhssdmNMMMNdNd/osomMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmNdhMNmNNMNmdNddohmMMNNNmdmdddNMMMMMMMMmMNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmNhmMmmmmNNmdNyoNMNmNmdhyyyhdhoyNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmdmMmmddddNmmdys+hmMMMmmhysssyy++dMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmdNMMdmdddmmNNyshmNNNNNNNdhhs+yy//dMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmNMMMdmdddmmMNysdmNNMMMNhhNdhs+y+/:mMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mmNMMNhmmddNNNMdyydmMMMNdyshNhyoss+:/MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmNMMddmmmmNMNMNdsymNNmdhhdNMNdhsss+:yMMMMMMMMMMMMMMMMNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMdhmmmmmNMNNMmshNMMMmmMMMMMmNdyo+//NMMMMMMMMMMMMMMMhNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMmhmmmmmmNMMNNMyshdhhhyhNMMMMMMdhso+sMMMMMMMMMMMMMMMhmMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMmdmmmmmmmNMMMmNm+ys++oyyNMMMMMMNmmyyoyNMMMMMMMMMMMMMddMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmmmmmmmmmmmNMNNmNNyyo+/oohNMMMMMMMMdhhsshmMMMMMMMMMMMyNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mmNNNNNNmmmmNMMNmmddNmmdhhdmMMMMMMMMMNddhssshmmNNNmmdhdMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NNNNNNNNNNNNNNNNmNNNNMMMMMNomMMMMMMMMMNNmdhhyyyyyyyhdmMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
Nd+oNMMMMMMMmodo++++++++++m..yNMMMMMNo+mNMMmhssshdNMMNhNMMMMMMMMMMMddMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MN+ /NMMMMMm: d` -ssssss+`d. `+mMMMMN. dNm+:+syso//hNN--yNMMMMMMMd+`yMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMN+ /NMMMm: oM` +NMMMMMNdN. /`.yNMMN. dh.omMMMMMNy.oM- `:hNMMMm+.  yMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMN/ /NMm: oNy` :sssmMMMMN. dh-`/mMN. d-/NMMMMMMMMy`m- y/`/dmo..o: yMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMN/ /m: +NNy. /yyyNMMMMN. dNNo`.yN- d.oNMMMMMMMMd d- mNh-`.`+mN/ yMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMN/ . +NMMN- oNMMMMMNdN. dMMMd:`/. ds.dNMMMMMMm::M- dMMNy/dMMN/ yMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMN/ +NMMMN- /yyyyyys d. dMMMMNo`  dNy-+ymmmho-+NN- dMMMMMMMMN/ yMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMNyNMMMMN+::::::::::m+/mMMMMMMd: dMMNho///+ymMMN+/mMMMMMMMMNs/hMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMNMMMMMMMMMMMMMMMMMMMMMMMMMMMMNsmMMMMMMMMMMMMMMNNNNMMNNNMMNNNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNMMMMMMMMMMMMMMNMMNMNMMMNMMNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNMMNMNMMMNMMNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNNNNMMNNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
*/
import { readFileSync, writeFileSync, mkdir, unlinkSync, existsSync } from 'fs';
import latestVersion from 'latest-version';
import { Whatsapp } from '../api/whatsapp';
import { CreateConfig, defaultOptions } from '../config/create-config';
import { upToDate } from '../utils/semver';
import { isAuthenticated, isInsideChat,asciiQr, retrieveQR, SessionTokenCkeck, scrapeDesconnected, checkWebpackJsonp, checkDeleteToken } from './auth';
import { initWhatsapp, injectApi, initBrowser } from './browser';
import chalk = require('chalk');
import boxen = require('boxen');
import Spinnies = require('spinnies');
import path = require('path');
const { version } = require('../../package.json');
import { scrapeImgReload, scrapeImg, deleteFiles, injectState, webpackJsonpWI } from '../api/helpers';
import { Browser, Page } from 'puppeteer';
import { clearInterval, clearTimeout, setInterval } from 'timers';

// Global
let updatesChecked = false;

/**
 * Start the bot
 * @param session, You must pass a string type parameter, this parameter will be the name of the client's session. If the parameter is not passed, the section name will be "session".
 * @param catchQR, A callback will be received, informing the status of the qrcode
 * @param statusFind, A callback will be received, informing the customer's status
 * @param options, Pass an object with the bot settings
 * @param browserSessionToken, Pass the session token information you can receive this token with the await client.getSessionTokenBrowser () function
 * @returns Whatsapp page, with this parameter you will be able to access the bot functions
 */

export async function create(
  session = 'session',
  catchQR?: (qrCode: string, asciiQR: string, attempt: number) => void,
  statusFind?: (statusGet: string, session: string) => void,
  options?: CreateConfig,
  browserSessionToken?: object
): Promise<Whatsapp> {
  var _fail: any,
    browser_check: any,
    closeBrowser: any,
    browserToken: any,
    Session: string,
    Session = session,
    DelFileCheck = false,
    waPage:Page,
    authenticated = null;
    interface waPage {
      isClosed: any;
    }
  const spinnies = new Spinnies({
    disableSpins: options ? options.disableSpins : '',
  });

  const mergedOptions = { ...defaultOptions, ...options };

  if (!mergedOptions.disableWelcome) {
    console.log(`
     
    ▐█  ██  █░▐█▀▀▀░▐█     ▄█▀▀█▄ ▄█▀▀█▄ ▐██   ██▌ ▓█▀▀▀░
     █▌▐██▄▓█ ▐█▄▄▄ ▐█    ▐█      █▒  ▐█▄▐█▀▌ ▐▌█▌ ▓█▄▄▄
     ▐██ ▐██░ ▐█    ▐█    ▐█▄  ▄▀ █▌  ▐█ ▐█ █▓█ █▌ ██
      ▀▀  ▀▀  ▀▀▀▀▀░▐▀▀▀▀▀  ▀▀▀▀   ▀▀▀▀  ▐▀  ▀  ▀▀ ▀▀▀▀▀
                                   ▄
      ▄▄░          ▄ ▄▄▄▄▄▄▄▄▄▄▄▄▄ ██         ▄▄       ▄▄▄▄      ░
      ░██▄        ██ ███▀▀▀▀▀▀▀▀█▌ ███▌       ██▄  ▄▄█▀▀▀▀▀▀█▄   ▓█▄           ▄█░
       ░██▄     ░██▀ ███           ██▀██▄     ██▄ ▄█░        ▀█▄ ▓███▄      ░████░
         ██▌   ▄██░ ▄███▄▄▄▄       ██  ▓██▄   ██▄▐█           ▐█ ▓█▌▀██▄  ▄███░██░
          ██▌ ▄██░  ▀███▀▀▀▀       ██   ▐██▌  ██▄▐█           ▐█░▓█▌  ▀█████░  ██░
           ▓████     ███           ██     ▀██▄██▄ █▌          ██ ▓█▌    ▀█░    ██░
            ▀██      ███        █▌ ██       ▀███▄  ▀█▄     ▄▄█▀  ▓█▌           ██░
             ▀       ▀███████████▌ ██        ░██▄    ▀▀███▀▀░    ▀█▌           ▓█░
                                              ▀░                                   \n`);
  }

  // Check for updates if needed
  if (!updatesChecked && mergedOptions.updatesLog) {
    spinnies.add(`${Session}-venom-version-spinner`, {
      text: 'Checking for updates',
    });
    checkVenomVersion(spinnies, Session);
    updatesChecked = true;
  }

  // Initialize whatsapp
  spinnies.add(`${Session}-auth`, {
    text: 'Waiting...',
  });

  // Opening a connection through the browser or wss
  var browser = await initBrowser(Session, mergedOptions);

  // Erro of connect wss
  if (browser === 'connect') {
    spinnies.fail(`${Session}-auth`, {
      text: `Error when try to connect ${mergedOptions.browserWS}`,
    });
    browser = null;
    throw `Error when try to connect ${mergedOptions.browserWS}`;
  }

    // Erro open browser
    if (browser === 'launch') {
        spinnies.fail(`${Session}-auth`, {
          text: `Error no open browser`,
        });
        browser = null;
          throw `Error no open browser`;
    }

    if (!mergedOptions.browserWS) {
   
      spinnies.add(`${Session}-browser`, {
      text: 'check headless',
    });

    //check if the browser is visible or not
    if (mergedOptions.headless) {
      spinnies.succeed(`${Session}-browser`, {
        text: 'headless option is active, browser hidden',
      });
    } else {
      spinnies.succeed(`${Session}-browser`, {
        text: 'headless option is disabled, browser visible',
      });
    }
    
    // checking that the browser has been closed
      browser['_process'].once('close', () => {
        browser['isClose'] = true;
      });

    }
    
     // disconnect (wss) or close (browser) 
    _fail = setInterval(() => {

      if (mergedOptions.browserWS) {
        if (browser.isConnected() === false) {
          spinnies.add(`${Session}-auths`, {
            text: '....',
          });

          spinnies.fail(`${Session}-auths`, {
            text: `The server is closed ${Session}`,
          });

          if (statusFind) {
            statusFind('serverClose', Session);
          }
          browser.close(); //close browser
          clearTimeout(closeBrowser);
          clearInterval(browser_check);
          clearInterval(_fail);
        
        }
      }

      if (browser['isClose'] != undefined && !mergedOptions.browserWS) {
        spinnies.add(`${Session}-auths`, {
          text: '....',
        });
        spinnies.fail(`${Session}-auths`, {
          text: 'The browser is closed',
        });
        if (statusFind) {
          statusFind('browserClose', Session);
        }
    
        clearTimeout(closeBrowser);
        clearInterval(_fail);
       
      }
    }, 1000);

    if (SessionTokenCkeck(browserSessionToken)) {
      browserToken = browserSessionToken;
    }

    waPage = await initWhatsapp(
      Session,
      mergedOptions,
      browser,
      browserToken
    );

    if (typeof waPage.isClosed === 'function' && waPage.isClosed() === false) {
      spinnies.update(`${Session}-auth`, { text: 'Authenticating...' });

      deleteToken(waPage, Session, mergedOptions, spinnies, async () => {
        if (statusFind) {
          statusFind('deleteToken', Session);
        }
      });

      // inject state
      await scrapeWebpackJsonp(
        waPage,
        closeBrowser,
        spinnies,
        _fail,
        browser_check,
        Session,
        browser,
        mergedOptions,
        (statusGet, session)=>{
          if(statusFind){
            statusFind(statusGet, Session);
          }
        });



      //session authenticated
      await isAuthenticated(waPage)
        .then((e) => {
          authenticated = e;
        })
        .catch((e) => {
          authenticated = e;
        });

        
        // If not authenticated, show QR and wait for scan
        if (authenticated === true) {
        //if everything is right with the customer

          if (statusFind) {
            statusFind('isLogged', Session);
          }
          // Wait til inside chat
          await isInsideChat(waPage).toPromise();

          spinnies.succeed(`${Session}-auth`, { text: 'Authenticated' });

        }else{
   
          
          if(waPage.isClosed() === false){

          //if the customer is not logged in
          if (statusFind) {
            statusFind('notLogged', Session);
          }

          spinnies.add(`${Session}-autoclose`, { text: 'check autoClose' });

          //on autoclose
          closeBrowser =  autoCloseF(
                      closeBrowser,
                      mergedOptions,
                      spinnies,
                      _fail,
                      browser_check,
                      Session,
                      browser, 
                      (statusGet, session) =>{
                        if(statusFind){
                          statusFind(statusGet, session);
                        }
                        },
                      )
                    
          // qrcode
          browser_check = scrapQrcodeTime (
                      browser_check,
                      mergedOptions,
                          spinnies,
                            browser, 
                            waPage,
                            Session,
                       closeBrowser,
                              _fail,
                          (statusGet, session)=>{
                            if(statusFind){
                              statusFind(statusGet, Session);
                            }
                          },
                          (qrCode, asciiQR, attempt)=>{
                            if(catchQR){
                              catchQR(qrCode, asciiQR, attempt);
                            }
                          },
                      
                      )

          // wait for the client to read the qrcode
          var IsLog = await isInsideChat(waPage).toPromise();

          if (IsLog == false) {
            spinnies.fail(`${Session}-auth`, {
              text: 'Not Login',
            });
            throw 'Error in login';
          }
            if (statusFind) {
              statusFind('qrReadSuccess', Session);
            }
             spinnies.succeed(`${Session}-auth`, {
                text: 'Compilation Mutation',
              });

          }else{
              spinnies.fail(`${Session}-auth`, { text: 'Fail authenticating!' });
              throw 'The browser is closed';
          }
          
        }
        
       await tokenSave(
          browser_check, 
          closeBrowser,
          spinnies,
          mergedOptions,
          browserToken,
          Session,
          waPage
          )


        if (mergedOptions.debug) {
          const debugURL = `http://localhost:${readFileSync(
            `./${Session}/DevToolsActivePort`
          ).slice(0, -54)}`;
          console.log(`\nDebug: \x1b[34m${debugURL}\x1b[0m`);
        }
       /*/ await autoCloseWI(
          closeBrowser,
          spinnies,
          _fail,
          browser_check,
          Session,
          browser, 
          waPage,
          (statusfid, Session) => {
            if(statusFind){
              statusFind(statusfid, Session);
            }
          }
          );*/
        reloadDesc(
          browserToken,
          mergedOptions,
          spinnies,
          closeBrowser,
          _fail,
          browser_check,
          browser,
          waPage,
          Session,
          (statusfid, Session) => {
            if(statusFind){
              statusFind(statusfid, Session);
            }
          },
          (qrCode, asciiQR, attempt) => {
            if(catchQR){
              catchQR(qrCode, asciiQR, attempt);
            }
          }).catch(()=>{});

        return new Whatsapp(waPage);
      
    }else{
      spinnies.fail(`${Session}-auth`, {
        text: 'Fail to connect',
      });
      throw 'The browser is closed';
    }
}

/**
 * Checs for a new versoin of venom and logs
 */
function checkVenomVersion(spinnies: any, session: string) {
  latestVersion('venom-bot').then((latest) => {
    if (!upToDate(version, latest)) {
      logUpdateAvailable(version, latest);
    }
    spinnies.succeed(`${session}-venom-version-spinner`, { text: 'Checking for updates' });
  });
}

async function deleteToken(waPage: Page, Session: string, mergedOptions: any, spinnies: any, C?: (t: boolean) => void): Promise<Boolean>{
  var checkDelete = await checkDeleteToken(waPage).toPromise();
  if(checkDelete === true){
    deleteFiles(mergedOptions, Session, spinnies);
    if (C) {
        C(checkDelete);
    }
    return checkDelete;
  }
}

/**
 * scrape Desconnected
 */
async function scrapeDesc(waPage: Page, session: string, mergedOptions: any, spinnies: any, D?: (t: boolean) => void): Promise<Boolean>{
  let clientExit = await scrapeDesconnected(waPage).toPromise();
   if(clientExit == true){
      deleteFiles(mergedOptions, session, spinnies);
      if(D){
        D(clientExit);
      }
      return clientExit;
  }
}
/**
 * scrape inject state
 */
async function scrapeWebpackJsonp(
  waPage: Page,
  closeBrowser: any,
  spinnies: any,
  _fail: any,
  browser_check: any,
  Session: string,
  browser: Browser, 
  mergedOptions: any,
  statusWS:(
       status: string, 
      session: string
    ) 
    => void
    ): Promise<any>{
  var WebpackJsonp = setInterval(async ()=>{
                var ch = await checkWebpackJsonp(waPage).toPromise();
                if(ch === true){
                  await injectState(waPage);
                  await webpackJsonpWI(waPage, (date: string)=>{
                      console.log("LOG: ", date);
                    if(date === "PAIRING" || date === "UNPAIRED"){
                      if(mergedOptions.autoClose > 0) {
                        spinnies.succeed(`${Session}-autoclose`, {
                          text: 'the autoClose function is on',
                        });      
                    closeBrowser = setTimeout(() => {
                                    browser.disconnect(); // disconnect wss
                                    browser.close();  //close browser
                                    if (statusWS) {
                                      statusWS("autocloseCalled", Session);
                                    }
                                    spinnies.add(`${Session}-auths`, {
                                      text: `....`,
                                    });
                                    spinnies.fail(`${Session}-auths`, {
                                      text: `Session Autoclose Called`,
                                    });
                
                                    clearInterval(_fail);
                                    clearInterval(browser_check);
                                  },
                                  mergedOptions.autoClose
                           );
                          }else{  
                          spinnies.succeed(`${Session}-autoclose`, {
                            text: 'the autoClose function is off ',
                          });
                        }
                  }else{
                    clearTimeout(closeBrowser);
                  }

                  });
                  clearInterval(WebpackJsonp);
                }
             }, 1000);
}

/**
 * AutoClose Without Internet
 */
/*async function autoCloseWI(
  closeBrowser: any,
  spinnies: any,
  _fail: any,
  browser_check: any,
  Session: string,
  browser: Browser, 
  waPage: Page,
  statusWS:(
       status: string, 
      session: string
    ) => void,
  ){


    await webpackJsonpWI(waPage, (e: string)=>{
        if(e === "PAIRING"){
          setTimeout(async function(){  
            browser.disconnect(); 
            browser.close();
            if (statusWS) {
              statusWS("autocloseCalledWS", Session);
            }
            spinnies.add(`${Session}-authsWS`, {
              text: `....`,
            });
            spinnies.fail(`${Session}-authsWS`, {
              text: `Session Autoclose Called`,
            });
            clearInterval(_fail);
            clearInterval(browser_check);
            clearTimeout(closeBrowser);
          }, 3000);
      }
    });
 
}*/

/**
 * reload function qrcode
 */
async function reloadDesc(
  browserToken: any,
  mergedOptions: any, 
  spinnies: any, 
  closeBrowser: any, 
  _fail: any, 
  browser_check: any,
  browser: Browser,
  waPage: Page, 
  Session: string,
  callfid?:(
    statusfid: string,
    session: string
  ) => void,
  callqr?:(
    callCode: string,
    callciiQR: string,
    callattempt: number
  ) => void
  ): Promise<any>{

   return new Promise(async (resolve, reject) => {
    await scrapeDesc(waPage, Session, mergedOptions, spinnies, async () => {
      if(waPage.isClosed() === false){
            if(callfid){
               callfid('desconnectedMobile', Session);
            }
            if(callfid){
              callfid('deleteToken', Session);
            }

            spinnies.add(`${Session}-autoclose`, { text: 'check autoClose' });
            spinnies.add(`${Session}-auth`, { text: 'Scan QR... ' });
    
              //on autoclose
             /* closeBrowser = autoCloseF(
                        closeBrowser,
                        mergedOptions,
                        spinnies,
                        _fail,

                        browser_check,
                        Session,
                        browser, 
                        (statusGet, session) =>{
                          if(callfid){
                            callfid(statusGet, session);
                          }
                          },
                        );*/
             
              // qrcode
              browser_check = scrapQrcodeTime (
                        browser_check,
                        mergedOptions,
                            spinnies,
                              browser, 
                              waPage,
                              Session,
                          closeBrowser,
                                _fail,
                            (statusGet, session) => {
                              if(callfid){
                                callfid(statusGet, Session);
                              }
                            },
                            (qrCode, asciiQR, attempt) => {
                              if(callqr){
                                callqr(qrCode, asciiQR, attempt);
                              }
                            },
                        );
  
              // wait for the client to read the qrcode
              var IsLog = await isInsideChat(waPage).toPromise();
  
              if(IsLog == false){
                spinnies.fail(`${Session}-auth`, {
                  text: 'Not Login',
                });
                 reject('Error in login');
                 return false;
              }
              
              if(callfid){
                callfid('qrReadSuccess', Session);
              }
              
              spinnies.succeed(`${Session}-auth`, {
                  text: 'Compilation Mutation',
                });

            await tokenSave(
                  browser_check, 
                  closeBrowser,
                  spinnies,
                  mergedOptions,
                  browserToken,
                  Session,
                  waPage
                  );

            reloadDesc(
                  browserToken, 
                  mergedOptions, 
                  spinnies, 
                  closeBrowser, 
                  _fail,
                  browser_check, 
                  browser, 
                  waPage, 
                  Session
                  ).catch((e)=>{ 
                    reject(e);
                    return false;
                  });
            }else{
              spinnies.fail(`${Session}-auth`, {
                text: 'Fail to connect',
              });
              reject('The browser is closed');
              return false;
            }
          
          });
        });
}
/**
 * Save token
 */
async function tokenSave(
  browser_check: any, 
  closeBrowser: any,
  spinnies: any,
  mergedOptions: any,
  browserToken: any,
  Session: string,
  waPage: Page
  ){
    
  clearInterval(browser_check);
  clearTimeout(closeBrowser);

  spinnies.add(`${Session}-inject`, { text: 'Injecting Sibionte...' });
  waPage = await injectApi(waPage);
  spinnies.succeed(`${Session}-inject`, {
    text: 'Starting With Success!',
  });

  // Saving Token
  spinnies.add(`${Session}-inject`, { text: 'Saving Token...' });

  if (true || (browserToken && !mergedOptions.createPathFileToken)) {
    const localStorage = JSON.parse(
      await waPage.evaluate(() => {
        return JSON.stringify(window.localStorage);
      })
    );

    let {
      WABrowserId,
      WASecretBundle,
      WAToken1,
      WAToken2,
    } = localStorage;

    try {
      setTimeout(() => {
        mkdir(
          path.join(
            path.resolve(
              process.cwd() + mergedOptions.mkdirFolderToken,
              mergedOptions.folderNameToken
            )
          ),
          { recursive: true },
          (err) => {
            if (err) {
              spinnies.fail(`${Session}-inject`, {
                text: 'Failed to create folder tokens...',
              });
            }
          }
        );
      }, 200);

      setTimeout(() => {
        writeFileSync(
          path.join(
            path.resolve(
              process.cwd() + mergedOptions.mkdirFolderToken,
              mergedOptions.folderNameToken
            ),
            `${Session}.data.json`
          ),
          JSON.stringify({
            WABrowserId,
            WASecretBundle,
            WAToken1,
            WAToken2,
          })
        );
        spinnies.succeed(`${Session}-inject`, {
          text: 'Token saved successfully...',
        });
      }, 500);
    } catch (error) {
      spinnies.fail(`${Session}-inject`, {
        text: 'Failed to save token...',
      });
    }
  }
}

/**
 * AutoClose
 */
function autoCloseF(
  closeBrowser: any,
  mergedOptions: any,
  spinnies: any,
  _fail: any,
  browser_check: any,
  Session: string,
  browser: Browser, 
  statusFc:(
    statusGet: string, 
      session: string
    ) => void,
  ): any {
    if(mergedOptions.autoClose > 0) {
        spinnies.succeed(`${Session}-autoclose`, {
          text: 'the autoClose function is on',
        });      
    closeBrowser = setTimeout(() => {
                    browser.disconnect(); // disconnect wss
                    browser.close();  //close browser
                    if (statusFc) {
                      statusFc("autocloseCalled", Session);
                    }
                    spinnies.add(`${Session}-auths`, {
                      text: `....`,
                    });
                    spinnies.fail(`${Session}-auths`, {
                      text: `Session Autoclose Called`,
                    });

                    clearInterval(_fail);
                    clearInterval(browser_check);
                  },
                  mergedOptions.autoClose
           );
          }else{  
          spinnies.succeed(`${Session}-autoclose`, {
            text: 'the autoClose function is off ',
          });
        }
    return closeBrowser;
}

/**
 * Scrape QRCODE
 */
 function scrapQrcodeTime (
    browser_check: any,
    mergedOptions: any,
         spinnies: any,
          browser: Browser, 
           waPage: Page,
          Session: string,
     closeBrowser: any,
            _fail: any,
          statusF: (
        statusGet: string, 
          session: string
          ) => void,
            catQR: (
           qrCode: string, 
          asciiQR: string, 
          attempt: number
         ) => void,

    ): any {
        let tipo_qr = 0, attempt = 0, result = undefined, url = null;
          // Scraper qrcode
       browser_check = setInterval(async () => {
            // Close client browser

            if (
              browser['isClose'] != undefined ||
              browser.isConnected() === false
            ) {
              if (statusF) {
                statusF('qrReadFail', Session);
              }

              clearTimeout(closeBrowser);
              clearInterval(_fail);
              clearInterval(browser_check);

            } else {
              switch (tipo_qr) {
                case 0:
                  result = await scrapeImg(waPage).catch(() => {});
                  if (result != undefined) {
                    var retri = await retrieveQR(waPage).catch(() => {});
                    if (retri) {
                      var { data, asciiQR } = retri;
                      if (catQR) {
                        catQR(data, asciiQR, attempt++);
                      }
                      await asciiQr(result['url'])
                        .then((qr) => {
                          if (mergedOptions.logQR) {
                            spinnies.update(`${Session}-auth`, {
                              text: 'Scan QR for Session: ' + Session,
                            });
                            console.log(qr);
                          }
                          tipo_qr++;
                        })
                        .catch(() => {});
                    }
                  }
                  break;
                case 1:
                  result = await scrapeImgReload(waPage, url).catch(() => {});
                  if (typeof result === 'object') {
                    url = result.url;
                  }
                  if (typeof result === 'object' && result.status === true) {
                    let re = await scrapeImg(waPage).catch(() => {});
                    if (re != undefined) {
                      var retri = await retrieveQR(waPage).catch(() => {});
                      if (retri) {
                        var { data, asciiQR } = retri;
                        if (catQR) {
                          catQR(data, asciiQR, attempt++);
                        }
                        await asciiQr(re['url'])
                          .then((qr) => {
                            if (mergedOptions.logQR) {
                              spinnies.update(`${Session}-auth`, {
                                text: 'Scan QR for Session: ' + Session,
                              });
                              console.log(qr);
                            }
                          })
                          .catch(() => {});
                      }
                    }
                  }
                  break;
              }
            }
          }, 1000);
        return browser_check;
}

/**
 * Logs a boxen of instructions to update
 * @param current
 * @param latest
 */
function logUpdateAvailable(current: string, latest: string) {
  // prettier-ignore
  const newVersionLog =
    `There is a new version of ${chalk.bold(`Venom`)} ${chalk.gray(current)} ➜  ${chalk.bold.green(latest)}\n` +
    `Update your package by running:\n\n` +
    `${chalk.bold('\>')} ${chalk.blueBright('npm update venom-bot')}`;

  console.log(boxen(newVersionLog, { padding: 1 }));
  console.log(
    `For more info visit: ${chalk.underline(
      'https://github.com/orkestral/venom/blob/master/Update.md'
    )}\n`
  );
}
