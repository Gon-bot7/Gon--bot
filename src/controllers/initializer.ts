/*
NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mMMMMMMMMMNNNmmNNNMMNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mmNMMNMMMMNNNNNmmmddhdddNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mddNMMNy:/odNmmddmmNNmdhhddmNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmmdNMNd:--+dNmmddhhddmmhsyhhmdmmNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmNmdNmy:.-oyNmmmhmdhho+sososyhhhddNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmmNdh+-`.:oyNNdmmdmmdo-://oysssyhhhdmNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
Nmmmoyyyo+osdNmdmmddNNhs+/::/+osyssydyhdNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NNmhsymMMNmmmmdmdNNddNmsso+++////ossssyyhdmNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mhhhmNNMNNNhssshhmmddmmssyooooso/::+oysshhhhmMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mmdhdddNNdyoosyhdmddmmmsoooooyysyys/::/oyyhhhyMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mdddhddmhsooshdmdmdhhyyyysso/ooo+syhhs/-/+shyhMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
dyyhdmd+ososhdmdmyyhhhhhhhyo++o/+///+ohhso++sdMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
dhdmNNdsossyhmdmsydhssssyhhs/++o/o+//:++yhhy+/hNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mdmNNNNmhysshddyshdyyy/oss+s::/:://++///++++/::hmNNNNNNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NNMNNNmmNNdymNNhshdshdyhdysh+sy+-:++osssosss++yNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmNNNmdNNmNmmmNmyyddyyhdhydyohys/-oo+osssysyyohNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mmNNNhdNmmNNmNMMNhyyhhhdhyyhmmyh+-/s+sysssyyhyydNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mNMMMhdNdmMNMMMMMNNmdhdddmhdmmNho/-osoyyo++oyddhhNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NMMMNmhNdNMNMNMMNmNNNmmmdyoohmhoyo::hsooo++oooydhymMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMNNNhmNNMmmNMNNmmmmdmmdyhhoyddddoo++yoyysooossyhsmMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMNNNmmNNNmdNdNmmddhhhdNNhsmNssdooo/dso++osyyysoymMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMNNNNmNNNNNmddmmNhshNmmmNmNMdhNsh/ohho++/:++MMNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MNNNMMNNNNmmmhhhhdyosdNmdmMMhoNmhdmys+ooo++/+MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mmNNNMMNNNNmddmdoodmMMNmmNNhssdmNMMMNdNd/osomMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmNdhMNmNNMNmdNddohmMMNNNmdmdddNMMMMMMMMmMNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmNhmMmmmmNNmdNyoNMNmNmdhyyyhdhoyNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmdmMmmddddNmmdys+hmMMMmmhysssyy++dMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmdNMMdmdddmmNNyshmNNNNNNNdhhs+yy//dMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmNMMMdmdddmmMNysdmNNMMMNhhNdhs+y+/:mMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mmNMMNhmmddNNNMdyydmMMMNdyshNhyoss+:/MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmNMMddmmmmNMNMNdsymNNmdhhdNMNdhsss+:yMMMMMMMMMMMMMMMMNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMdhmmmmmNMNNMmshNMMMmmMMMMMmNdyo+//NMMMMMMMMMMMMMMMhNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMmhmmmmmmNMMNNMyshdhhhyhNMMMMMMdhso+sMMMMMMMMMMMMMMMhmMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMmdmmmmmmmNMMMmNm+ys++oyyNMMMMMMNmmyyoyNMMMMMMMMMMMMMddMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmmmmmmmmmmmNMNNmNNyyo+/oohNMMMMMMMMdhhsshmMMMMMMMMMMMyNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mmNNNNNNmmmmNMMNmmddNmmdhhdmMMMMMMMMMNddhssshmmNNNmmdhdMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NNNNNNNNNNNNNNNNmNNNNMMMMMNomMMMMMMMMMNNmdhhyyyyyyyhdmMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
Nd+oNMMMMMMMmodo++++++++++m..yNMMMMMNo+mNMMmhssshdNMMNhNMMMMMMMMMMMddMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MN+ /NMMMMMm: d` -ssssss+`d. `+mMMMMN. dNm+:+syso//hNN--yNMMMMMMMd+`yMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMN+ /NMMMm: oM` +NMMMMMNdN. /`.yNMMN. dh.omMMMMMNy.oM- `:hNMMMm+.  yMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMN/ /NMm: oNy` :sssmMMMMN. dh-`/mMN. d-/NMMMMMMMMy`m- y/`/dmo..o: yMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMN/ /m: +NNy. /yyyNMMMMN. dNNo`.yN- d.oNMMMMMMMMd d- mNh-`.`+mN/ yMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMN/ . +NMMN- oNMMMMMNdN. dMMMd:`/. ds.dNMMMMMMm::M- dMMNy/dMMN/ yMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMN/ +NMMMN- /yyyyyys d. dMMMMNo`  dNy-+ymmmho-+NN- dMMMMMMMMN/ yMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMNyNMMMMN+::::::::::m+/mMMMMMMd: dMMNho///+ymMMN+/mMMMMMMMMNs/hMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMNMMMMMMMMMMMMMMMMMMMMMMMMMMMMNsmMMMMMMMMMMMMMMNNNNMMNNNMMNNNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNMMMMMMMMMMMMMMNMMNMNMMMNMMNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNMMNMNMMMNMMNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNNNNMMNNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
*/
import { readFileSync, writeFileSync, mkdir, unlinkSync, existsSync } from 'fs';
import latestVersion from 'latest-version';
import { Whatsapp } from '../api/whatsapp';
import { CreateConfig, defaultOptions } from '../config/create-config';
import { upToDate } from '../utils/semver';
import { asciiQr, retrieveQR, SessionTokenCkeck, scrapeDesconnected, checkWebpackJsonp, checkDeleteToken, stateInject } from './auth';
import { initWhatsapp, injectApi, initBrowser } from './browser';
import chalk = require('chalk');
import boxen = require('boxen');
import Spinnies = require('spinnies');
import path = require('path');
const { version } = require('../../package.json');
import { scrapeImgReload, scrapeImg, deleteFiles, injectState, webpackJsonpWI } from '../api/helpers';
import { Browser, Page } from 'puppeteer';
import { clearInterval, clearTimeout, setInterval } from 'timers';

// Global
let updatesChecked = false;

/**
 * Start the bot
 * @param session, You must pass a string type parameter, this parameter will be the name of the client's session. If the parameter is not passed, the section name will be "session".
 * @param catchQR, A callback will be received, informing the status of the qrcode
 * @param statusFind, A callback will be received, informing the customer's status
 * @param options, Pass an object with the bot settings
 * @param browserSessionToken, Pass the session token information you can receive this token with the await client.getSessionTokenBrowser () function
 * @returns Whatsapp page, with this parameter you will be able to access the bot functions
 */

export async function create(
  Session = 'session',
  catchQR?: (qrCode: string, asciiQR: string, attempt: number) => void,
  statusFind?: (statusGet: string, session: string) => void,
  options?: CreateConfig,
  browserSessionToken?: object
): Promise<Whatsapp> {
  
  var disconnectOrClose: NodeJS.Timeout,
      AutoCloseBrowser: NodeJS.Timeout, //setTimeout autoClose
      intervalScrapeQrcode: NodeJS.Timeout, //setInterval qrcode
      browserToken: object, //inject browser
      waPage: Page; // puppeteer function

    interface waPage {
      isClosed: any;
    }

  const spinnies:Spinnies = new Spinnies({
    disableSpins: options ? options.disableSpins : '',
  });

  const mergedOptions = { ...defaultOptions, ...options };

  if (!mergedOptions.disableWelcome) {
    console.log(`
     
    ▐█  ██  █░▐█▀▀▀░▐█     ▄█▀▀█▄ ▄█▀▀█▄ ▐██   ██▌ ▓█▀▀▀░
     █▌▐██▄▓█ ▐█▄▄▄ ▐█    ▐█      █▒  ▐█▄▐█▀▌ ▐▌█▌ ▓█▄▄▄
     ▐██ ▐██░ ▐█    ▐█    ▐█▄  ▄▀ █▌  ▐█ ▐█ █▓█ █▌ ██
      ▀▀  ▀▀  ▀▀▀▀▀░▐▀▀▀▀▀  ▀▀▀▀   ▀▀▀▀  ▐▀  ▀  ▀▀ ▀▀▀▀▀
                                   ▄
      ▄▄░          ▄ ▄▄▄▄▄▄▄▄▄▄▄▄▄ ██         ▄▄       ▄▄▄▄      ░
      ░██▄        ██ ███▀▀▀▀▀▀▀▀█▌ ███▌       ██▄  ▄▄█▀▀▀▀▀▀█▄   ▓█▄           ▄█░
       ░██▄     ░██▀ ███           ██▀██▄     ██▄ ▄█░        ▀█▄ ▓███▄      ░████░
         ██▌   ▄██░ ▄███▄▄▄▄       ██  ▓██▄   ██▄▐█           ▐█ ▓█▌▀██▄  ▄███░██░
          ██▌ ▄██░  ▀███▀▀▀▀       ██   ▐██▌  ██▄▐█           ▐█░▓█▌  ▀█████░  ██░
           ▓████     ███           ██     ▀██▄██▄ █▌          ██ ▓█▌    ▀█░    ██░
            ▀██      ███        █▌ ██       ▀███▄  ▀█▄     ▄▄█▀  ▓█▌           ██░
             ▀       ▀███████████▌ ██        ░██▄    ▀▀███▀▀░    ▀█▌           ▓█░
                                              ▀░                                   \n`);
  }

  // Check for updates if needed
  if(!updatesChecked && mergedOptions.updatesLog){
    spinnies.add(`${Session}-venom-version-spinner`,{
      text: 'Checking for updates',
    });
    checkVenomVersion(spinnies, Session);
    updatesChecked = true;
  }

  // Initialize whatsapp
  spinnies.add(`${Session}-browser`, {
    text: 'Waiting... checking the browser...',
  });

  // Opening a connection through the browser or wss
  var browser = await initBrowser(Session, mergedOptions);

    // Erro of connect wss
    if(browser === 'connect'){
        spinnies.fail(`${Session}-browser`, {
          text: `Error when try to connect ${mergedOptions.browserWS}`,
        });
        throw `Error when try to connect ${mergedOptions.browserWS}`;
    }

    // Erro open browser
    if (browser === 'launch') {
        spinnies.fail(`${Session}-browser`, {
          text: `Error no open browser`,
        });
        throw `Error no open browser`;
      }

        spinnies.succeed(`${Session}-browser`, {
          text: `Browser successfully opened`,
        });
    
    // check if the wss function is on
    if(!mergedOptions.browserWS) {

        spinnies.add(`${Session}-browserActive`, {
            text: 'check headless',
        });

    //check if the browser is visible or not
    if(mergedOptions.headless){
        spinnies.succeed(`${Session}-browserActive`, {
          text: 'headless option is active, browser hidden',
        });
      }else{
        spinnies.succeed(`${Session}-browserActive`, {
          text: 'headless option is disabled, browser visible',
        });
    }
    
    // checking that the browser has been closed
      browser['_process'].once('close', () => {
        browser['isClose'] = true;
      });

    }
     
     // disconnect (wss) or close (browser) 
     disconnectOrClose = setInterval(() => {

      // disconnect (wss)
      if(mergedOptions.browserWS){
        if(browser.isConnected() === false){
          spinnies.add(`${Session}-wss`, {
            text: '....',
          });

          spinnies.fail(`${Session}-wss`, {
            text: `The server is closed ${Session}`,
          });

          if(statusFind){
            statusFind('serverClose', Session);
          }

          browser.close();
          clearTimeout(AutoCloseBrowser);// clear autoClose
          clearInterval(intervalScrapeQrcode);
          clearInterval(disconnectOrClose);
        }
      }

      if(browser['isClose'] != undefined && !mergedOptions.browserWS){
            
            spinnies.add(`${Session}-browserClose`, {
              text: '....',
            });

            spinnies.fail(`${Session}-browserClose`, {
              text: 'The browser is closed',
            });

            if(statusFind){
              statusFind('browserClose', Session);
            }

            clearTimeout(AutoCloseBrowser);// clear autoClose
            clearInterval(disconnectOrClose);
        }
       }, 1000);

      if(SessionTokenCkeck(browserSessionToken)){
        browserToken = browserSessionToken;
      }

      waPage = await initWhatsapp(
        Session,
        mergedOptions,
        browser,
        browserToken
      );

    if(typeof waPage.isClosed === 'function' && waPage.isClosed() === false){
      spinnies.update(`${Session}-auth`, { text: 'Authenticating...' });
      deleteToken(waPage, Session, mergedOptions, spinnies, async () => {
          if (statusFind) {
            statusFind('deleteToken', Session);
          }
        });

        // inject state
        try{
            var result = await scrapeWebpackJsonp(
              waPage, 
              AutoCloseBrowser, 
              spinnies, 
              disconnectOrClose, 
              intervalScrapeQrcode, 
              Session, 
              browser, 
              mergedOptions, 
              browserToken, 
                (statusGet, session)=>{
                  if(statusFind){
                    statusFind(statusGet, Session);
                  }
                });
          if(result){
            return new Whatsapp(waPage);
          }
               
        }catch(e){
          throw e;
        }
            
    }
}

/**
 * Checs for a new versoin of venom and logs
 */
function checkVenomVersion(spinnies: any, session: string) {
  latestVersion('venom-bot').then((latest) => {
    if (!upToDate(version, latest)) {
      logUpdateAvailable(version, latest);
    }
    spinnies.succeed(`${session}-venom-version-spinner`, { text: 'Checking for updates' });
  });
}

async function deleteToken(waPage: Page, Session: string, mergedOptions: any, spinnies: any, C?: (t: boolean) => void): Promise<Boolean>{
  var checkDelete = await checkDeleteToken(waPage).toPromise();
  if(checkDelete === true){
    deleteFiles(mergedOptions, Session, spinnies);
    if (C) {
        C(checkDelete);
    }
    return checkDelete;
  }
}

/**
 * scrape Desconnected
 */
async function scrapeDesc(waPage: Page, session: string, mergedOptions: any, spinnies: any, D?: (t: boolean) => void): Promise<Boolean>{
  let clientExit = await scrapeDesconnected(waPage).toPromise();
   if(clientExit == true){
      deleteFiles(mergedOptions, session, spinnies);
      if(D){
        D(clientExit);
      }
      return clientExit;
  }
}
/**
 * scrape inject state
 */
async function scrapeWebpackJsonp(
  waPage: Page,
  AutoCloseBrowser: NodeJS.Timeout,
  spinnies: any,
  disconnectOrClose: NodeJS.Timeout,
  intervalScrapeQrcode: NodeJS.Timeout,
  Session: string,
  browser: Browser, 
  mergedOptions: any,
  browserToken: object,
  statusWS:(
       status: string, 
      session: string
    ) 
    => void,
  callqr?:(
      callCode: string,
      callciiQR: string,
      callattempt: number
  ) => void
    ): Promise<any>{

      var connect: boolean = true, unpaired: boolean = true;
      
      return new Promise(async (resolve) => {
        try{
          var ch = await checkWebpackJsonp(waPage).toPromise();
            if(ch){
                var inj = await injectState(waPage);
                  if(inj === true){
                    console.log("injectState");
                  }
            }
          }catch{
               console.log("error inject state");
          }

          var inject = await stateInject(waPage).toPromise();

          if(inject === true){
          
            await webpackJsonpWI(waPage, async (state: string) => {
             console.log("LOG: ", state);

            if(state === "UNPAIRED"){
            
              (unpaired)? statusWS('notLogged', Session) : unpaired = !unpaired;

              spinnies.add(`${Session}-autoclose`, { 
                text: 'check autoClose' 
              });

              //check options autoclose 
           if(mergedOptions.autoClose > 0) {

                spinnies.succeed(`${Session}-autoclose`,{
                  text: 'The autoClose function is on',
                });      
                
                AutoCloseBrowser = setTimeout(() => {
                                    browser.disconnect();
                                    browser.close(); 

                                    if(statusWS){
                                      statusWS("autocloseCalled", Session);
                                    }

                                    spinnies.add(`${Session}-autoClose`, {
                                      text: `....`,
                                    });

                                    spinnies.fail(`${Session}-autoClose`, {
                                      text: `Session Autoclose Called`,
                                    });

                                    clearInterval(disconnectOrClose);
                                    clearInterval(intervalScrapeQrcode);
                                },
                              mergedOptions.autoClose 
                             );
                    }else{  
                    spinnies.succeed(`${Session}-autoclose`, {
                      text: 'The autoClose function is off ',
                    });
                  }
            
                  intervalScrapeQrcode = scrapQrcodeTime(
                    intervalScrapeQrcode,
                          mergedOptions,
                              spinnies,
                                browser, 
                                waPage,
                                Session,
                                AutoCloseBrowser,
                                disconnectOrClose,
                              (statusGet, session) => {
                                if(statusWS){
                                  statusWS(statusGet, Session);
                                }
                              },
                              (qrCode, asciiQR, attempt) => {
                                if(callqr){
                                  callqr(qrCode, asciiQR, attempt);
                                }
                              },
                          );
                     
            }

            if(state === "CONNECTED" && connect === true){
                connect = !connect;
                if(statusWS){
                  statusWS('isLogged', Session);
                }
                await tokenSave(
                  intervalScrapeQrcode, 
                  AutoCloseBrowser,
                  spinnies,
                  mergedOptions,
                  browserToken,
                  Session,
                  waPage
                  );
                  resolve(true);
            }
          });

          waPage.evaluate(() => {
            window.injects(window.inject.default.state);
         }) 

        }  

       
 });
            
}


/**
 * Save token
 */
async function tokenSave(
  intervalScrapeQrcode: NodeJS.Timeout, 
  AutoCloseBrowser: NodeJS.Timeout,
  spinnies: any,
  mergedOptions: any,
  browserToken: object,
  Session: string,
  waPage: Page
  ){
    
  clearInterval(intervalScrapeQrcode);
  clearTimeout(AutoCloseBrowser);

  spinnies.add(`${Session}-inject`, { text: 'Injecting Sibionte...' });
  waPage = await injectApi(waPage);
  spinnies.succeed(`${Session}-inject`, {
    text: 'Starting With Success!',
  });

  // Saving Token
  spinnies.add(`${Session}-inject`, { text: 'Saving Token...' });

  if (true || (browserToken && !mergedOptions.createPathFileToken)) {
    const localStorage = JSON.parse(
      await waPage.evaluate(() => {
        return JSON.stringify(window.localStorage);
      })
    );

    let {
      WABrowserId,
      WASecretBundle,
      WAToken1,
      WAToken2,
    } = localStorage;

    try {
      setTimeout(() => {
        mkdir(
          path.join(
            path.resolve(
              process.cwd() + mergedOptions.mkdirFolderToken,
              mergedOptions.folderNameToken
            )
          ),
          { recursive: true },
          (err) => {
            if (err) {
              spinnies.fail(`${Session}-inject`, {
                text: 'Failed to create folder tokens...',
              });
            }
          }
        );
      }, 200);

      setTimeout(() => {
        writeFileSync(
          path.join(
            path.resolve(
              process.cwd() + mergedOptions.mkdirFolderToken,
              mergedOptions.folderNameToken
            ),
            `${Session}.data.json`
          ),
          JSON.stringify({
            WABrowserId,
            WASecretBundle,
            WAToken1,
            WAToken2,
          })
        );
        spinnies.succeed(`${Session}-inject`, {
          text: 'Token saved successfully...',
        });
      }, 500);
    } catch (error) {
      spinnies.fail(`${Session}-inject`, {
        text: 'Failed to save token...',
      });
    }
  }
}

/**
 * AutoClose
 */
function autoCloseF(
  AutoCloseBrowser: NodeJS.Timeout,
  mergedOptions: any,
  spinnies: any,
  disconnectOrClose: NodeJS.Timeout,
  intervalScrapeQrcode: NodeJS.Timeout,
  Session: string,
  browser: Browser, 
  statusFc:(
    statusGet: string, 
      session: string
    ) => void,
  ): NodeJS.Timeout {
    if(mergedOptions.autoClose > 0) {
        spinnies.succeed(`${Session}-autoclose`, {
          text: 'the autoClose function is on',
        });      
        AutoCloseBrowser = setTimeout(() => {
                    browser.disconnect(); // disconnect wss
                    browser.close();  //close browser
                    if (statusFc) {
                      statusFc("autocloseCalled", Session);
                    }
                    spinnies.add(`${Session}-auths`, {
                      text: `....`,
                    });
                    spinnies.fail(`${Session}-auths`, {
                      text: `Session Autoclose Called`,
                    });

                    clearInterval(disconnectOrClose);
                    clearInterval(intervalScrapeQrcode);
                  },
                  mergedOptions.autoClose
           );
          }else{  
          spinnies.succeed(`${Session}-autoclose`, {
            text: 'the autoClose function is off ',
          });
        }
    return AutoCloseBrowser;
}

/**
 * Scrape QRCODE
 */
 function scrapQrcodeTime (
  intervalScrapeQrcode: NodeJS.Timeout,
    mergedOptions: any,
         spinnies: any,
          browser: Browser, 
           waPage: Page,
          Session: string,
          AutoCloseBrowser: NodeJS.Timeout,
          disconnectOrClose: NodeJS.Timeout,
          statusF: (
        statusGet: string, 
          session: string
          ) => void,
            catQR: (
           qrCode: string, 
          asciiQR: string, 
          attempt: number
         ) => void,

    ): any {
        let tipo_qr = 0, attempt = 0, result = undefined, url = null;
          // Scraper qrcode
          intervalScrapeQrcode = setInterval(async () => {
            // Close client browser

            if (
              browser['isClose'] != undefined ||
              browser.isConnected() === false
            ) {
              if (statusF) {
                statusF('qrReadFail', Session);
              }

              clearTimeout(AutoCloseBrowser);
              clearInterval(disconnectOrClose);
              clearInterval(intervalScrapeQrcode);

            } else {
              switch (tipo_qr) {
                case 0:
                  result = await scrapeImg(waPage).catch(() => {});
                  if (result != undefined) {
                    var retri = await retrieveQR(waPage).catch(() => {});
                    if (retri) {
                      var { data, asciiQR } = retri;
                      if (catQR) {
                        catQR(data, asciiQR, attempt++);
                      }
                      await asciiQr(result['url'])
                        .then((qr) => {
                          if (mergedOptions.logQR) {
                            spinnies.update(`${Session}-auth`, {
                              text: 'Scan QR for Session: ' + Session,
                            });
                            console.log(qr);
                          }
                          tipo_qr++;
                        })
                        .catch(() => {});
                    }
                  }
                  break;
                case 1:
                  result = await scrapeImgReload(waPage, url).catch(() => {});
                  if (typeof result === 'object') {
                    url = result.url;
                  }
                  if (typeof result === 'object' && result.status === true) {
                    let re = await scrapeImg(waPage).catch(() => {});
                    if (re != undefined) {
                      var retri = await retrieveQR(waPage).catch(() => {});
                      if (retri) {
                        var { data, asciiQR } = retri;
                        if (catQR) {
                          catQR(data, asciiQR, attempt++);
                        }
                        await asciiQr(re['url'])
                          .then((qr) => {
                            if (mergedOptions.logQR) {
                              spinnies.update(`${Session}-auth`, {
                                text: 'Scan QR for Session: ' + Session,
                              });
                              console.log(qr);
                            }
                          })
                          .catch(() => {});
                      }
                    }
                  }
                  break;
              }
            }
          }, 1000);
        return intervalScrapeQrcode;
}

/**
 * Logs a boxen of instructions to update
 * @param current
 * @param latest
 */
function logUpdateAvailable(current: string, latest: string) {
  // prettier-ignore
  const newVersionLog =
    `There is a new version of ${chalk.bold(`Venom`)} ${chalk.gray(current)} ➜  ${chalk.bold.green(latest)}\n` +
    `Update your package by running:\n\n` +
    `${chalk.bold('\>')} ${chalk.blueBright('npm update venom-bot')}`;

  console.log(boxen(newVersionLog, { padding: 1 }));
  console.log(
    `For more info visit: ${chalk.underline(
      'https://github.com/orkestral/venom/blob/master/Update.md'
    )}\n`
  );
}
